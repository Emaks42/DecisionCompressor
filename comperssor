# загрузка изображений
import functools

from PIL import Image
from DTC import *
input_ = 'alpha.bmp'
arr = np.asarray(Image.open("pictures/" + input_),dtype=np.uint64)
print(arr)

# приведение к виду обучающих данных
a = np.arange(0, arr.shape[0], 1)
b = np.arange(0, arr.shape[1], 1)
AB = np.meshgrid(a, b)
X = np.c_[AB[1].ravel(), AB[0].ravel()]
if len(arr[0][0]) == 4:
    arr_ = np.apply_along_axis(lambda x: x[0] * 256 ** 3 + x[1] * 256 ** 2 + x[2] * 256 ** 1 + x[3] * 256 ** 0, 1,
                               arr.reshape((arr.shape[0] * arr.shape[1], arr.shape[2])))
else:
    arr_ = np.apply_along_axis(lambda x: x[0] * 256 ** 2 + x[1] * 256 ** 1 + x[2] * 256 ** 0, 1,
                               arr.reshape((arr.shape[0] * arr.shape[1], arr.shape[2])))
im_ = list(np.unique(arr_))
y = arr_
for i in np.arange(len(im_)):
  np.place(y, y == im_[i],[i])
print(y, len(im_))

# переобучение
df = pd.DataFrame(data=X,
                  columns=["x","y"])
root = DecisionTree()
root.fit(df, y)
root.print_conditions()
print(root.count_all_nodes())

# сохранение данных в файл
file = open("compressed/" + input_.split(".")[0]+".dtcc", "wb")
width = len(arr[0]).to_bytes(2)
height = len(arr).to_bytes(2)
col_cou = (len(im_)*2 + (1 if len(arr[0][0]) == 4 else 0)).to_bytes(4)
file.write(width)
file.write(height)
file.write(col_cou)
colors = []
for i in im_:
    colors.append((int(i)).to_bytes(len(arr[0][0]), byteorder="big"))
file.write(b"".join(colors))
bit_size_lim = max(len(bin(len(arr))[2:]), len(bin(len(arr[0]))[2:]), len(bin(len(im_))[2:]))
tree = root.encode_to_bits(bit_size_lim, root.root)
print(tree)
if len(tree) % 16 != 0:
    tree += "0" * (len(tree) % 16)
byted_tree = b""
for sig in range(0,len(tree)-16,16):
    o = int(tree[sig:sig+16],2)
    byted_tree += o.to_bytes(2)
file.write(byted_tree)
file.close()
